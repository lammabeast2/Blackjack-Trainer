// --------- Config / Constants ----------
const RANKS = ['2','3','4','5','6','7','8','9','10','J','Q','K','A'];
const VALUES = { '2':2,'3':3,'4':4,'5':5,'6':6,'7':7,'8':8,'9':9,'10':10,'J':10,'Q':10,'K':10,'A':11 };
const HI_LO = { '2':1,'3':1,'4':1,'5':1,'6':1,'7':0,'8':0,'9':0,'10':-1,'J':-1,'Q':-1,'K':-1,'A':-1 };

const RULES = {
  numDecks: 6,
  penetration: 0.75, // reshuffle when 25% left
  S17: true,         // dealer stands on soft 17
  DAS: true,         // double after split allowed
  blackjackPays: 1.5,
  oneSplit: true     // allow exactly one split (no resplit)
};

// Basic Strategy (S17, DAS, no surrender) - Pairs / Soft / Hard
const PAIRS = {
 'A': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'P',8:'P',9:'P',10:'P','A':'P'},
 '10':{2:'S',3:'S',4:'S',5:'S',6:'S',7:'S',8:'S',9:'S',10:'S','A':'S'},
 '9': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'S',8:'P',9:'P',10:'S','A':'S'},
 '8': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'P',8:'P',9:'P',10:'P','A':'P'},
 '7': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'P',8:'H',9:'H',10:'H','A':'H'},
 '6': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'H',8:'H',9:'H',10:'H','A':'H'},
 '5': {2:'D',3:'D',4:'D',5:'D',6:'D',7:'D',8:'D',9:'D',10:'H','A':'H'},
 '4': {2:'H',3:'H',4:'H',5:'P',6:'P',7:'H',8:'H',9:'H',10:'H','A':'H'},
 '3': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'P',8:'H',9:'H',10:'H','A':'H'},
 '2': {2:'P',3:'P',4:'P',5:'P',6:'P',7:'P',8:'H',9:'H',10:'H','A':'H'},
};

const SOFT = {
  2:{2:'H',3:'H',4:'H',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  3:{2:'H',3:'H',4:'H',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  4:{2:'H',3:'H',4:'D',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  5:{2:'H',3:'H',4:'D',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  6:{2:'H',3:'D',4:'D',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  7:{2:'S',3:'D',4:'D',5:'D',6:'D',7:'S',8:'S',9:'H',10:'H','A':'H'},
  8:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'S',8:'S',9:'S',10:'S','A':'S'},
  9:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'S',8:'S',9:'S',10:'S','A':'S'},
  10:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'S',8:'S',9:'S',10:'S','A':'S'},
};

const HARD = {
  5:{2:'H',3:'H',4:'H',5:'H',6:'H',7:'H',8:'H',9:'H',10:'H','A':'H'},
  6:{2:'H',3:'H',4:'H',5:'H',6:'H',7:'H',8:'H',9:'H',10:'H','A':'H'},
  7:{2:'H',3:'H',4:'H',5:'H',6:'H',7:'H',8:'H',9:'H',10:'H','A':'H'},
  8:{2:'H',3:'H',4:'H',5:'H',6:'H',7:'H',8:'H',9:'H',10:'H','A':'H'},
  9:{2:'H',3:'D',4:'D',5:'D',6:'D',7:'H',8:'H',9:'H',10:'H','A':'H'},
  10:{2:'D',3:'D',4:'D',5:'D',6:'D',7:'D',8:'D',9:'D',10:'H','A':'H'},
  11:{2:'D',3:'D',4:'D',5:'D',6:'D',7:'D',8:'D',9:'D',10:'D','A':'H'},
  12:{2:'H',3:'H',4:'S',5:'S',6:'S',7:'H',8:'H',9:'H',10:'H','A':'H'},
  13:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'H',8:'H',9:'H',10:'H','A':'H'},
  14:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'H',8:'H',9:'H',10:'H','A':'H'},
  15:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'H',8:'H',9:'H',10:'H','A':'H'},
  16:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'H',8:'H',9:'H',10:'H','A':'H'},
  17:{2:'S',3:'S',4:'S',5:'S',6:'S',7:'S',8:'S',9:'S',10:'S','A':'S'},
};

// --------- Utilities ----------
const el = s => document.querySelector(s);
const els = s => [...document.querySelectorAll(s)];

function handValue(hand) {
  let total = 0, aces = 0;
  for (const r of hand) { total += VALUES[r]; if (r === 'A') aces++; }
  while (total > 21 && aces) { total -= 10; aces--; }
  return total;
}
function isBlackjack(hand){ return hand.length === 2 && handValue(hand) === 21; }
function canSplit(hand){ return hand.length === 2 && hand[0] === hand[1]; }
function isSoft(hand) {
  // true if any Ace counted as 11
  let total = 0, aces = 0;
  for (const r of hand) { total += VALUES[r]; if (r==='A') aces++; }
  return aces>0 && total <= 21;
}
function upTo10(rank){ if (['J','Q','K','10'].includes(rank)) return 10; if (rank==='A') return 11; return parseInt(rank,10); }

function basicStrategy(player, dealerUp, canSplitNow, canDoubleNow){
  // Split first
  if (canSplitNow && canSplit(player)) {
    const pr = player[0];
    const chart = PAIRS[pr];
    if (chart) {
      let a = chart[dealerUp] ?? chart[10];
      if (a === 'D') return canDoubleNow ? 'D' : 'H';
      if (a) return a;
    }
  }
  // Soft?
  if (player.includes('A') && handValue(player) <= 21) {
    const nonA = player.filter(r=>r!=='A');
    if (nonA.length === 1) {
      const x = upTo10(nonA[0]);
      const chart = SOFT[x];
      if (chart) {
        let a = chart[dealerUp] ?? chart[10];
        if (a === 'D') return canDoubleNow ? 'D' : 'H';
        if (a) return a;
      }
    }
  }
  // Hard
  const t = handValue(player);
  if (t >= 18) return 'S';
  const chart = HARD[t];
  if (chart){
    let a = chart[dealerUp] ?? chart[10];
    if (a === 'D') return canDoubleNow ? 'D' : 'H';
    return a ?? 'H';
  }
  return 'H';
}

// --------- Shoe / Counting ----------
class Shoe {
  constructor(numDecks=RULES.numDecks, penetration=RULES.penetration){
    this.numDecks = numDecks;
    this.penetration = penetration;
    this.reset();
  }
  reset(){
    this.cards = [];
    for (let d=0; d<this.numDecks; d++){
      for (let s=0;s<4;s++) for (const r of RANKS) this.cards.push(r);
    }
    // shuffle
    for (let i=this.cards.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [this.cards[i], this.cards[j]] = [this.cards[j], this.cards[i]];
    }
    this.initialSize = this.cards.length;
    this.cutIndex = Math.floor(this.initialSize * (1 - this.penetration));
    this.runningCount = 0;
  }
  decksRemaining(){
    return Math.max(0.25, this.cards.length/52);
  }
  trueCount(){
    return this.runningCount / this.decksRemaining();
  }
  needShuffle(){
    return this.cards.length <= this.cutIndex;
  }
  draw(){ // raw draw (doesn't update RC; caller decides when it's "seen")
    if (this.cards.length === 0) throw new Error("Shoe empty");
    return this.cards.pop();
  }
  see(rank){ // update running count when a card becomes visible
    this.runningCount += HI_LO[rank];
  }
}

// --------- Game State ----------
const state = {
  bankroll: 1000,
  currentBet: 10,
  shoe: new Shoe(),
  mode: 'free', // 'free' | 'practice'
  playerHands: [], // [{cards:[], bet:n, canSplit:false, canDouble:false, done:false, note:""}]
  activeIndex: 0,
  dealer: { up:null, hole:null, cards:[], holeRevealed:false },
  allowSplitOnce: true,
  dealerHolePendingSeen: null, // store count to apply when revealed
};

// --------- Rendering ----------
function render(){
  el('#bankroll').textContent = state.bankroll;
  el('#rc').textContent = state.shoe.runningCount >= 0 ? `+${state.shoe.runningCount}` : `${state.shoe.runningCount}`;
  el('#tc').textContent = state.shoe.trueCount().toFixed(2);
  el('#shoeInfo').textContent = `${state.shoe.numDecks} decks • ${state.shoe.cards.length} cards left`;

  // Toggle coach panel
  el('#coach').classList.toggle('hidden', state.mode !== 'practice');

  // Dealer
  const dWrap = el('#dealerCards');
  dWrap.innerHTML = '';
  const d = state.dealer;
  d.cards.forEach((r, idx)=>{
    const div = document.createElement('div');
    div.className = 'card' + ((idx===1 && !d.holeRevealed) ? ' hole':'');
    div.textContent = (idx===1 && !d.holeRevealed) ? '??' : r;
    dWrap.appendChild(div);
  });
  el('#dealerTotal').textContent = d.holeRevealed ? handValue(d.cards) : (d.cards.length? handValue([d.cards[0]]): '?');

  // Player hands
  const pWrap = el('#playerHands');
  pWrap.innerHTML = '';
  state.playerHands.forEach((h, i)=>{
    const container = document.createElement('div');
    container.className = 'hand' + (i===state.activeIndex ? ' active':'');
    const header = document.createElement('div');
    header.className = 'header';
    const l = document.createElement('div');
    l.innerHTML = `Hand ${i+1} — Bet $${h.bet} <span class="badge">${h.done?'Done':'Playing'}</span>`;
    const r = document.createElement('div');
    r.innerHTML = `Total: <strong>${handValue(h.cards)}</strong>`;
    header.appendChild(l); header.appendChild(r);
    container.appendChild(header);

    const cards = document.createElement('div');
    cards.className = 'cards';
    h.cards.forEach(rank=>{
      const c = document.createElement('div');
      c.className = 'card';
      c.textContent = rank;
      cards.appendChild(c);
    });
    container.appendChild(cards);

    if (h.note){
      const note = document.createElement('div');
      note.className = 'badge ' + (h.noteType||'');
      note.textContent = h.note;
      container.appendChild(note);
    }

    pWrap.appendChild(container);
  });

  // Buttons availability
  const inRound = state.playerHands.length > 0 && !allHandsDone();
  el('#hitBtn').disabled = !inRound;
  el('#standBtn').disabled = !inRound;
  el('#doubleBtn').disabled = !inRound || !currentHand().canDouble;
  el('#splitBtn').disabled = !inRound || !(currentHand().canSplit && canSplit(currentHand().cards) && state.allowSplitOnce);

  // Show recommended move (practice)
  if (state.mode === 'practice' && inRound){
    const rec = recommendForCurrent();
    el('#coachText').textContent = pretty(rec);
  } else {
    el('#coachText').textContent = '—';
  }
}

function pretty(a){ return ({H:'Hit', S:'Stand', D:'Double', P:'Split'})[a] || 'Hit'; }

// --------- Flow helpers ----------
function currentHand(){ return state.playerHands[state.activeIndex]; }
function allHandsDone(){ return state.playerHands.every(h => h.done || handValue(h.cards) >= 21); }

function settleAll(){
  // Reveal hole card and apply its count to RC
  if (!state.dealer.holeRevealed){
    state.dealer.holeRevealed = true;
    state.shoe.see(state.dealer.hole);
  }
  // Dealer plays if any live hand and dealer not blackjack
  const anyLive = state.playerHands.some(h=>handValue(h.cards)<=21);
  let dealerBJ = isBlackjack(state.dealer.cards);
  let dealerTotal = handValue(state.dealer.cards);
  if (anyLive && !dealerBJ){
    while (dealerTotal < 17 || (dealerTotal === 17 && !RULES.S17 && isSoft(state.dealer.cards))){
      const r = state.shoe.draw(); state.dealer.cards.push(r); state.shoe.see(r);
      dealerTotal = handValue(state.dealer.cards);
    }
  }
  // Settle
  let net = 0;
  state.playerHands.forEach(h=>{
    const pt = handValue(h.cards);
    const pbj = isBlackjack(h.cards);
    const dbj = dealerBJ;
    const dt = dealerTotal;

    let result = 0;
    if (pbj && !dbj) result = Math.floor(RULES.blackjackPays * h.bet);
    else if (dbj && !pbj) result = -h.bet;
    else if (pt > 21) result = -h.bet;
    else if (dt > 21) result = +h.bet;
    else if (pt > dt) result = +h.bet;
    else if (pt < dt) result = -h.bet;
    else result = 0;

    net += result;
    h.note = result>0?'WIN':(result<0?'LOSS':'PUSH');
    h.noteType = result>0?'win':(result<0?'loss':'push');
    h.done = true;
  });
  state.bankroll += net;
  el('#result').textContent = `Result: ${net >= 0 ? '+' : ''}${net}`;
  render();
}

// --------- Round Controls ----------
function newShoe(){
  state.shoe = new Shoe();
  state.shoe.reset();
  state.dealer = { up:null, hole:null, cards:[], holeRevealed:false };
  state.playerHands = [];
  state.activeIndex = 0;
  state.allowSplitOnce = true;
  el('#result').textContent = 'New shoe shuffled.';
  render();
}

function deal(){
  // end last round
  state.dealer = { up:null, hole:null, cards:[], holeRevealed:false };
  state.playerHands = [];
  state.activeIndex = 0;
  state.allowSplitOnce = true;
  el('#result').textContent = '';

  if (state.shoe.needShuffle()) { newShoe(); }

  const betEl = el('#bet'); state.currentBet = Math.max(1, parseInt(betEl.value||'10', 10));
  const p = { cards:[], bet: state.currentBet, canSplit:true, canDouble:true, done:false, note:'' };
  const d = state.dealer;

  // Initial deal; count only "seen" cards: player's 2 + dealer upcard
  // Player 1
  let r = state.shoe.draw(); p.cards.push(r); state.shoe.see(r);
  r = state.shoe.draw(); d.up = r; d.cards.push(r); state.shoe.see(r);
  r = state.shoe.draw(); p.cards.push(r); state.shoe.see(r);
  r = state.shoe.draw(); d.hole = r; d.cards.push(r);
  // don't see() hole until reveal

  state.playerHands.push(p);

  // Check immediate blackjacks only at settlement
  render();
}

function recommendForCurrent(){
  const hand = currentHand();
  const canSplitNow = state.allowSplitOnce && hand.canSplit && canSplit(hand.cards);
  const canDoubleNow = hand.canDouble;
  const dealerUp = state.dealer.up;
  return basicStrategy(hand.cards, dealerUp, canSplitNow, canDoubleNow);
}

function doAction(action){
  const h = currentHand();

  // Practice coaching
  if (state.mode === 'practice'){
    const rec = recommendForCurrent();
    if (action !== rec){
      el('#coachText').textContent = `Not optimal. Best: ${pretty(rec)}.`;
    } else {
      el('#coachText').textContent = `Nice — ${pretty(rec)} is optimal.`;
    }
  }

  if (action === 'H'){
    const r = state.shoe.draw(); h.cards.push(r); state.shoe.see(r);
    h.canDouble = false; // after hit, no double
  } else if (action === 'S'){
    h.done = true;
  } else if (action === 'D'){
    if (!h.canDouble) return;
    const r = state.shoe.draw(); h.cards.push(r); state.shoe.see(r);
    h.bet *= 2; h.canDouble = false; h.done = true;
  } else if (action === 'P'){
    if (!(state.allowSplitOnce && canSplit(h.cards))) return;
    // split into two hands
    const left = { cards:[h.cards[0]], bet:h.bet, canSplit:false, canDouble:true, done:false, note:'' };
    const right= { cards:[h.cards[1]], bet:h.bet, canSplit:false, canDouble:true, done:false, note:'' };
    // draw one to each
    let r1 = state.shoe.draw(); left.cards.push(r1); state.shoe.see(r1);
    let r2 = state.shoe.draw(); right.cards.push(r2); state.shoe.see(r2);
    // Split Aces: one card only each, then done
    if (left.cards[0]==='A' && right.cards[0]==='A'){
      left.done = true; right.done = true; left.canDouble = false; right.canDouble = false;
    }
    // replace current with left; insert right after
    state.playerHands[state.activeIndex] = left;
    state.playerHands.splice(state.activeIndex+1,0,right);
    state.allowSplitOnce = !RULES.oneSplit ? true : false;
  }

  // Bust / natural stops
  if (handValue(h.cards) >= 21) h.done = true;

  // Advance to next hand if current done
  while (state.activeIndex < state.playerHands.length && state.playerHands[state.activeIndex].done){
    state.activeIndex++;
  }

  // Finish round if all done
  if (state.activeIndex >= state.playerHands.length){
    settleAll();
  } else {
    render();
  }
}

// --------- Wiring UI ----------
el('#shuffleBtn').addEventListener('click', newShoe);
el('#dealBtn').addEventListener('click', deal);
el('#hitBtn').addEventListener('click', ()=>doAction('H'));
el('#standBtn').addEventListener('click', ()=>doAction('S'));
el('#doubleBtn').addEventListener('click', ()=>doAction('D'));
el('#splitBtn').addEventListener('click', ()=>doAction('P'));
els('input[name="mode"]').forEach(r=>r.addEventListener('change', e=>{
  state.mode = e.target.value;
  render();
}));

// Initialize UI
render();